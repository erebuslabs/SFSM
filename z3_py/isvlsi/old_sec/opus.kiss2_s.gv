#Total states is 0, including 0 states and 0 newstates
#Total transisions is 0, including 0 transistions and 0 new transitions
digraph finite_state_machine {
	rankdir=LR;
	size="20,20";
	resolution="300";
	overlap=false;

	node [shape = circle, fixedsize=true, width = 1, color = red, style = filled];
	IOwait_n;
 	RMACK_n;
 	WMACK_n;
 	init0_n;
 	init1_n;
 	init4_n;
 
	node [shape = circle, color = black, style = unfilled];
	*;
 	IOwait;
 	RMACK;
 	WMACK;
 	init0;
 	init1;
 	init2;
 	init4;
 	read0;
 	read1;
 	write0;
 	* -> init0;
	IOwait -> IOwait_n;
	IOwait -> RMACK;
	IOwait -> WMACK;
	IOwait -> init1;
	IOwait -> init2;
	IOwait -> read0;
	IOwait -> write0;
	IOwait_n -> IOwait;
	IOwait_n -> RMACK;
	IOwait_n -> WMACK;
	IOwait_n -> init1;
	IOwait_n -> init2;
	IOwait_n -> read0;
	IOwait_n -> write0;
	RMACK -> RMACK_n;
	RMACK -> read0;
	RMACK_n -> RMACK;
	RMACK_n -> read0;
	WMACK -> WMACK_n;
	WMACK -> write0;
	WMACK_n -> WMACK;
	WMACK_n -> write0;
	init0 -> init0_n;
	init0 -> init1;
	init0_n -> init0;
	init0_n -> init1;
	init1 -> init1_n;
	init1 -> init2;
	init1_n -> init1;
	init1_n -> init2;
	init2 -> init4;
	init4 -> IOwait;
	init4 -> init4_n;
	init4_n -> IOwait;
	init4_n -> init4;
	read0 -> read1;
	read1 -> IOwait;
	write0 -> IOwait;
}
